function [u,v] = cut_reconstr(tin,coef,varargin)
% S. Innocenti Adapted from ut_reconstr() for reeconstructing superposed harmonics
% 2019/10
%
% Generates hindcast and/or forecast/prediction at user-specified times
% using output from companion harmonic analysis function UT_SOLV().
% 
% Syntax for two-dimensional raw input, such as velocities:
%   [ u_fit, v_fit ] = UR_RECONSTR ( t_fit, coef , {options} );
% 
% Syntax for one-dimensional raw input, such as sea level:
%   [ sl_fit, ~ ] = cut_reconstr ( t_fit, coef , {options} ); 
%
%   Analysis of groups of records
%   The descriptions that follow next for INPUTS, DEFAULTS, OPTIONS, and 
%   OUTPUTS are for treatment of a single record. Following that, 
%   explanations are given for modifications that enable treating a group 
%   of records with a single execution.
% 
% INPUT: 
%   * t_fit = Column vector of arbitrary times [datenum UCT/GMT] distributed
%             uniformly or irregularly. Hindcast are produced at these time steps.
%             If t_fit include NaNs, the outputs (u_fit/v_fit or sl_fit) will put 
%             NaNs at the corresponding time steps. 
%   * coef  = results output structure from CUT_SOLV()
%   * u_fit & v_fit, or sl_fit = reconstructed superposed harmonics
%
% {OPTIONS} 
%
% OUTPUT:
%   * t_fit    = arbitrary times for reconstructed superposed harmonics
%   * u_fit & v_fit, or sl_fit = reconstructed superposed harmonics
%
%
%
% DEFAULTS
%
%   * Constituents with SNR > 2 are included in the superposition. 
%   * All other aspects of the calculation are determined by the 
%       information in coef, such that they match the calculation done 
%       by UT_SOLV(); to change them another run of UT_SOLV() is needed.
%
% OPTIONS
%
% Option flags are not case-sensitive but cannot be abbreviated. The order
%  of the option flags is not important but they must be passed in 
% after all other arguments. See report for more complete explanations.
%
%   ‘MinSNR’, MinSNR 
%
%       * Only include constituents with SNR >= MinSNR. Default MinSNR=2.
%
%   ‘MinPE’, MinPE 
%
%       * Only include constituents with PE > MinPE. Default MinPE=0. 
%
% If both of ‘MinSNR’ and ‘MinPE’ are selected no constituent with either 
%   SNR or PE values lower than the specified thresholds will be included.
%
%   ‘Cnstit’, Cnstit
%
%       * Include only those constituents named in Cnstit, which must be 
%           selected from those in coef.name.
%               Cnstit = cell array of 4-character strings.
%       * If ‘Cnstit’ is used then MinSNR and MinPE are ignored.
% 
% OUTPUTS
%
% u_fit & v_fit, or sl_fit
%
%   * Column vector(s) (same size as t_fit) containing the superposed
%       harmonics and the mean (and trend if included in model).
%
% GROUPS OF RECORDS
%
% Inputs are as in the single-record case except that t_fit can be either
%   a single n_t x 1 vector of times, to be used for all time sequences
%   in the group, or an n_t x n1 x n2 x n3 ... n-n_d array of times, which
%   specifies a different set of n_t times for each record. See comments
%   for UT_SOLV() for explanations of the parameters n1, n2, ..., n-n_d.
%
% Output is the same as in the single-record case except that u_fit & 
%   v_fit, or sl_fit, are n_t x n1 x n2 x n3 ... n-n_d arrays (the same 
%   size as the u_raw & v_raw, or sl_raw, inputs to the UT_SOLV() run
%   that created coef). 
%
% For more information see:
%   Codiga, D.L., 2011. Unified Tidal Analysis and Prediction Using the 
%       UTide Matlab Functions. Technical Report 2011-01. Graduate School 
%       of Oceanography, University of Rhode Island, Narragansett, RI. 
%       59pp. ftp://www.po.gso.uri.edu/pub/downloads/codiga/pubs/
%       2011Codiga-UTide-Report.pdf
%
% UTide v1p0 9/2011 d.codiga@gso.uri.edu


if isequal(size(coef.g,2),1) % single record 
    [u,v] = cut_reconstr1(tin,coef,varargin{:});
    
else % group of records
    n_t = size(tin,1); 
    % alln = [n_1 n_2 n_3 ... n_n_d]
    alln = size(coef.g);
    alln = alln(2:end);
    % check inputs
    if (~isequal(size(tin),[n_t 1]) && ~isequal(size(tin),[n_t alln]))
        error(['cut_reconstr(group): input times have neither acceptable'...
            ' size.']);
    end
    % n_d = number of dimensions of group
    n_d = length(alln);
    % n_s = number of time sequences in group
    n_s = prod(alln); 
    % nallc = number of all constituents
    nallc = size(coef.g,1);
    % reshape t to a vector
    if size(tin,2)>1
        tin = reshape(tin,n_t,n_s);
    end
    % reshape fields of coef to vectors
    if n_d > 1
        coef.g = reshape(coef.g,nallc,n_s);
        coef.g_ci = reshape(coef.g_ci,nallc,n_s);
        if coef.aux.opt.twodim 
            coef.Lsmaj = reshape(coef.Lsmaj,nallc,n_s);
            coef.Lsmaj_ci = reshape(coef.Lsmaj_ci,nallc,n_s);
            coef.Lsmin = reshape(coef.Lsmin,nallc,n_s);
            coef.Lsmin_ci = reshape(coef.Lsmin_ci,nallc,n_s);
            coef.theta = reshape(coef.theta,nallc,n_s);
            coef.theta_ci = reshape(coef.theta_ci,nallc,n_s);
            coef.umean = reshape(coef.umean,1,n_s);
            coef.vmean = reshape(coef.vmean,1,n_s);
            if ~coef.aux.opt.notrend
                coef.uslope = reshape(coef.uslope,1,n_s);
                coef.vslope = reshape(coef.vslope,1,n_s);
            end
        else
            coef.A    = reshape(coef.A,nallc,n_s);
            coef.A_ci = reshape(coef.A_ci,nallc,n_s);
            coef.mean = reshape(coef.mean,1,n_s);
            if ~coef.aux.opt.notrend
                coef.slope = reshape(coef.slope,1,n_s);
            end
        end
        coef.aux.reftime = reshape(coef.aux.reftime,1,n_s);
        if size(coef.aux.lat,2)>1
            coef.aux.lat = reshape(coef.aux.lat,1,n_s);
        end
    end
    % initialize storage
    u = nan*ones(n_t,n_s);
    if coef.aux.opt.twodim
        v = u;
    else
        v = [];
    end
    % main loop
    coef1.aux.frq = coef.aux.frq;
    coef1.aux.lind = coef.aux.lind;
    coef1.aux.opt = coef.aux.opt;
    for is = 1:n_s % for each time sequence
        if size(tin,2) > 1
            tin1 = tin(:,is);
        else
            tin1 = tin;
        end
        % select coef results for the is'th record
        coef1.name = coef.name;
        coef1.g    = coef.g(:,is);
        coef1.g_ci = coef.g_ci(:,is);
        if coef.aux.opt.twodim
            coef1.Lsmaj = coef.Lsmaj(:,is);
            coef1.Lsmaj_ci = coef.Lsmaj_ci(:,is);
            coef1.Lsmin = coef.Lsmin(:,is);
            coef1.Lsmin_ci = coef.Lsmin_ci(:,is);
            coef1.theta = coef.theta(:,is);
            coef1.theta_ci = coef.theta_ci(:,is);
            coef1.umean = coef.umean(is);
            coef1.vmean = coef.vmean(is);
            if ~coef.aux.opt.notrend
                coef1.uslope = coef.uslope(is);
                coef1.vslope = coef.vslope(is);
            end
        else
            coef1.A = coef.A(:,is);
            coef1.A_ci = coef.A_ci(:,is);
            coef1.mean = coef.mean(is);
            if ~coef.aux.opt.notrend
                coef1.slope = coef.slope(is);
            end
        end
        if size(coef.aux.lat,2)>1
            coef1.aux.lat = coef.aux.lat(is);
        else
            coef1.aux.lat = coef.aux.lat;
        end
        coef1.aux.reftime = coef.aux.reftime(is);
        % execute reconstruct for one record
        fprintf('[%d/%d]',is,n_s);
        [u1,v1] = cut_reconstr1(tin1,coef1,varargin{:});
        % store results
        u(:,is) = u1;
        if coef.aux.opt.twodim
            v(:,is) = v1;
        end
    end
    % reshape back to original array sizes
    if n_d > 1
        u = reshape(u,[n_t alln]);
        if coef.aux.opt.twodim
            v = reshape(v,[n_t alln]);
        end
    end
end

