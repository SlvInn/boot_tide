function [coef_boot,B] = cut_boot(tin,uin,vin,coef,n_boot,varargin)
% S. Innocenti, silvia.innocenti@ec.gc.ca, 2020/04
% Based on ut_reconstr() and ut_solv() [UTide v1p0 2011/09, 
% http://www.po.gso.uri.edu/~codiga/utide/utide.htm], and their 
% adapted versions cut_reconstr() and cut_solv()

% TO DO (some warnings have been set up for these issues):
% - define a more flexible way to treat the block length parameters 
%   (presently expressed in days, i.e. in the same units as MATLAB datenums)
% - finish checks on user-defined inputs;
% - test the functions for 2D analyses;
% - test models with inferred constituents for modified models; 
%
% NOTES:
% 1. NEVER TESTED FOR 2D-SERIES%
% 2. Not working for groups of records (this option was present in UTide, 
% but it has been eliminated here)
%
% OVERVIEW: 
% Construct residual bootstrap resamples from an HA regression. 
% Resamples are then used for estimating the coefficient distribution 
% in the view of further uncertainty analyses.
%
%
% Syntax for one- and two-dimensional raw input:
%  coef-boot = cut_boot( t_fit, uin, vin, coef, n_boot, {options} );
%
% INPUT:
%  tin - Tx1 vector of arbitrary times [datenum UCT/GMT],
%        It may include NaNs and time steps may be irregularly distributed 
%        but, in that case, set the MBB and ParBoot parameters carefully
%        (check the block length, etc., since internal variables and scripts have only 
%        been tested for hourly data)
%         
% uin, vin  - Tx1 vectors observed water level or 2D current series observed at the 
%        tin time steps. They may include NaNs.
%
%   coef - coefficient structure >> results output structure generated by cut_solv().
% n_boot - (int) Number of bootstrap resamples used to generate the distributions
%
%
% {OPTIONS}:
% 'method'/'mtd', mtdname - string indicating which bootstrap algorithm must be used 
%               to construct the residual resamples. Accepted strings are:
%          'mbb' for implementing the Moving Block Boostrap (either with fixed or random block length')
%          'parboot', 'pboot', or 'psdboot' for the Semi-Parametric Bootstrap based on the residual power spectrum
%           Default: 'mbb'
%
% 'circular', true/false  - boolean flag determining if a circular strategy 
%           [Politis and Romano (1994)] must be used in constructing the resamples.
%           Default: false
%
% 'lblk_dist'/'blockdist', distname - string defining the probability distribution 
%            to extract/simulate the block lengths for each MBB resample. 
%            Allowed distname:
%            * 'fix'  - blocks with fixed length = ndays (see the 'blocklength' input below), 
%                       no distribution involved. 
%            * 'geom' - blocks with random lengths esimulated from a geometric distribution with 
%                       parameter 1/p = ndays (see the 'blocklength' input below)
%            * 'pois' - blocks with random lengths esimulated from a poisson distribution with 
%                       parameter lambda = ndays (see the 'blocklength' input below) 
%            * 'unif' - blocks with random lengths esimulated from an uniform distribution with 
%                       parameters [a,b] = ndays (see the 'blocklength' input below)
%             Default: blockdist = 'geom'
%          
% 'blocklength'/'lblk', ndays - block length [days] for fixed length block in MBB 
%                               Default: ndays = 31
%
% 'lblkpar'/'blocklengthparam', theta - block length distribution parameter(s) when using 
%           random blocks MBB. Specifically, theta has the following interpretations:
%            * inverse of the average block length for blockdist ='geom'. Default: 1/31 
%            * average block length for blockdist = 'pois'. Default: 30 
%            * min and max block length for blockdist = 'unif' (i.e. ndays is a 2-element vector). Default: [0,60] 
%
% 'seed', seeds - 2-element vector containing the random seeds to be used in the 
%           resampling. For MBB, the first seed is used in the simulation of the block 
%           random starts, while the second is used in the simulation of the block lengths.
%           For the SPB, only the first seed is used to initialize the fttnoise function.  
%
% 'knownweights'/'kweights'/'kw', kwvect - Tx1 or empty vector of known WLS weights to be cosidered 
%       in the HA regression of each resample. Default: kwvect = coef.W 
%       (i.e. use the original HA wls/irls weights, if present in coef). 
%       IF kwvect = [], the IRLS method is applied for each resample (robustfit.m), 
%       otherwise, the known weights are used as in a GLS. 
%       These weights represent estimates of the reciprocal of the observation std 
%       NOTE: weight are assumed w = 1 / sigma_ii, while some IRLS models use
%       bisquared weights [i.e., w = 1 / (sigma_ii^2)]; consider
%       using the sqrt of the weights through the option "knownweights", if needed. 
%      
% NOTE: The 'circular', 'blockdist', 'blocklength', and 'blocklengthparam' options
%       are ignored when using SPB. 
%
%
% OUTPUT:
% coef_boot - coefficient structure containing the following fields (assuming 
%             no trend in the model for the specification of the matrix sizes)
%
%                M - (2K+1) x n_boot matrix of sin-cos or complex regression 
%                    coefficients estimated for each resample.
% A or Lsmaj,Lsmin - K x n_boot matrices of tidal amplitudes estimated for each resample
%     g or g,theta - K x n_boot matrices of tidal phases estimated for each resample
%                W - Nx1 vector of known weights or Nxn_boot matrix of weights 
%                    estimated on each resample via the IRLS method.
%             mean - n_boot-element vector of HA regression intercepts 
%             boot - structure containing the generated residual resamples 
%         boot_opt - structure containing the detailed options used for generating 
%                    the residual and parameter resamples
%
% -------- 
% Politis and Romano (1994), DOI:10.1080/127301621459.1994.10476870



if isequal(size(coef.g,2),1) % single record 
    [coef_boot,B] = cut_boot1(tin,uin,vin,coef,n_boot,varargin{:});
    
else % group of records

    error 'to be checked here : test if it works for too dimensions and adapt the output (see cut_solve.m)'
    %{
    n_t = size(tin,1); 
    % alln = [n_1 n_2 n_3 ... n_n_d]
    alln = size(coef.g);
    alln = alln(2:end);
    % check inputs
    if (~isequal(size(tin),[n_t 1]) && ~isequal(size(tin),[n_t alln]))
        error(['cut_reconstr(group): input times have neither acceptable size.']);
    end
    % n_d = number of dimensions of group
    n_d = length(alln);
    % n_s = number of time sequences in group
    n_s = prod(alln); 
    % nallc = number of all constituents
    nallc = size(coef.g,1);
    % reshape t to a vector
    if size(tin,2)>1
        tin = reshape(tin,n_t,n_s);
    end
    % reshape fields of coef to vectors
    if n_d > 1
        coef.g = reshape(coef.g,nallc,n_s);
        coef.g_ci = reshape(coef.g_ci,nallc,n_s);
        if coef.aux.opt.twodim 
            coef.Lsmaj = reshape(coef.Lsmaj,nallc,n_s);
            coef.Lsmaj_ci = reshape(coef.Lsmaj_ci,nallc,n_s);
            coef.Lsmin = reshape(coef.Lsmin,nallc,n_s);
            coef.Lsmin_ci = reshape(coef.Lsmin_ci,nallc,n_s);
            coef.theta = reshape(coef.theta,nallc,n_s);
            coef.theta_ci = reshape(coef.theta_ci,nallc,n_s);
            coef.umean = reshape(coef.umean,1,n_s);
            coef.vmean = reshape(coef.vmean,1,n_s);
            if ~coef.aux.opt.notrend
                coef.uslope = reshape(coef.uslope,1,n_s);
                coef.vslope = reshape(coef.vslope,1,n_s);
            end
        else
            coef.A    = reshape(coef.A,nallc,n_s);
            coef.A_ci = reshape(coef.A_ci,nallc,n_s);
            coef.mean = reshape(coef.mean,1,n_s);
            if ~coef.aux.opt.notrend
                coef.slope = reshape(coef.slope,1,n_s);
            end
        end
        coef.aux.reftime = reshape(coef.aux.reftime,1,n_s);
        if size(coef.aux.lat,2)>1
            coef.aux.lat = reshape(coef.aux.lat,1,n_s);
        end
    end
    % initialize storage
    u = nan*ones(n_t,n_s);
    if coef.aux.opt.twodim
        v = u;
    else
        v = [];
    end
    % main loop
    coef1.aux.frq = coef.aux.frq;
    coef1.aux.lind = coef.aux.lind;
    coef1.aux.opt = coef.aux.opt;
    for is = 1:n_s % for each time sequence
        
% % %         if size(tin,2) > 1
% % %             tin1 = tin(:,is);
% % %         else
% % %             tin1 = tin;
% % %         end
        
           uin1 = uin(:,is);
        if ~isempty(vin)
            vin1 = vin(:,is);
        else
            vin1 = [];            
        end
        
        if isequal(size(uin),size(tin))
            tin1 = tin(:,is);
        else
            tin1 = tin;
        end
        
        
        % select coef results for the is'th record
        coef1.name = coef.name;
        coef1.g    = coef.g(:,is);
        coef1.g_ci = coef.g_ci(:,is);
        if coef.aux.opt.twodim
            coef1.Lsmaj = coef.Lsmaj(:,is);
            coef1.Lsmaj_ci = coef.Lsmaj_ci(:,is);
            coef1.Lsmin = coef.Lsmin(:,is);
            coef1.Lsmin_ci = coef.Lsmin_ci(:,is);
            coef1.theta = coef.theta(:,is);
            coef1.theta_ci = coef.theta_ci(:,is);
            coef1.umean = coef.umean(is);
            coef1.vmean = coef.vmean(is);
            if ~coef.aux.opt.notrend
                coef1.uslope = coef.uslope(is);
                coef1.vslope = coef.vslope(is);
            end
        else
            coef1.A = coef.A(:,is);
            coef1.A_ci = coef.A_ci(:,is);
            coef1.mean = coef.mean(is);
            if ~coef.aux.opt.notrend
                coef1.slope = coef.slope(is);
            end
        end
        if size(coef.aux.lat,2)>1
            coef1.aux.lat = coef.aux.lat(is);
        else
            coef1.aux.lat = coef.aux.lat;
        end
        coef1.aux.reftime = coef.aux.reftime(is);
        
        % execute reconstruct for one record
        % fprintf('[%d/%d]',is,n_s);
        
        coef_boot = cut_boot1(tin1,uin1,vin1,coef1,n_boot,varargin{:});
        
       
        
        % store results
% % %         u(:,is) = u1;
% % %         if coef.aux.opt.twodim
% % %             v(:,is) = v1;
% % %         end
    end
    
    % reshape back to original array sizes
%     if n_d > 1
%         u = reshape(u,[n_t alln]);
%         if coef.aux.opt.twodim
%             v = reshape(v,[n_t alln]);
%         end
%     end
%}
end

