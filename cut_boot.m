function [coef_boot,B] = cut_boot(tin,uin,vin,coef,n_boot,varargin)
% Construct bootstrap resamples for the estimation of coefficient probabily distribution.
%
% S. Innocenti 2020/04/27 
% Adapted from ut_reconstr() and ut_solv() - UTide v1p0 9/2011 d.codiga@gso.uri.edu
% NOTES: 
% 1. NEVER TESTED FOR 2D-SERIES
% 2. Not working for groups of records (this option was present in UTide
% but it has been eliminated)
%
% Syntax for one- and two-dimensional raw input:
%  COEFF_BOOT = UT_BOOT ( t_fit, uin, vin, coef, n_boot, {options} );
%
% INPUTS
% 
%  t_fit - time vector : column vector of arbitrary times, datenum UCT/GMT,
%          It may include NaNs and time steps may be irregularly
%          distributed but, in that case, set carefully the MBB and ParBoot
%          parameters (check the block length, etc.)
%          uniformly or irregularly (see. It may include NaNs and if so the outputs (u_fit/v_fit or sl_fit) will 
%          have corresponding NaNs. 
%
% uin, vin  - observed water level or 2D current series.
%           They may include NaNs
%
%   coef - coefficient structure >> results output structure generated by CUT_SOLV().M.
%
% n_boot - Number of bootstrap resamples used to geneate the distributions
%
% 
% OUTPUTS
%
% coef_boot - coefficient structure containing the following fields:
%
%        M - 
%        A - 
%        g - 
%        W - Nx1 vector of weight, estimates of the reciprocal of the observation std 
%            NOTE: weight are assumed w = 1 / sigma_ii, while some IRLS models use
%            bisquared weights [i.e., w = 1 / (sigma_ii^2)]; consider
%            using the sqrt of the weights through the option "knownweights", if needed. 
%     mean -
%     boot -
% boot_opt - 
%
%
% OPTIONS
%
%       'method'  or 'mtd'
%
%       'blocklength' or 'lblk'
%
%       'lblk_dist' or 'blockdist'
%
%       'seed'
%   
%       'knownweights', 'kweights' or 'kw' - 
%
%
% DEFAULTS for MBB:
%
%     
% DEFAULTS for ParBoot:
%
%
% 


if isequal(size(coef.g,2),1) % single record 
    [coef_boot,B] = cut_boot1(tin,uin,vin,coef,n_boot,varargin{:});
    
else % group of records

    error 'to be checked here : test if it works for too dimensions and adapt the output (see cut_solve.m)'
    %{
    n_t = size(tin,1); 
    % alln = [n_1 n_2 n_3 ... n_n_d]
    alln = size(coef.g);
    alln = alln(2:end);
    % check inputs
    if (~isequal(size(tin),[n_t 1]) && ~isequal(size(tin),[n_t alln]))
        error(['cut_reconstr(group): input times have neither acceptable size.']);
    end
    % n_d = number of dimensions of group
    n_d = length(alln);
    % n_s = number of time sequences in group
    n_s = prod(alln); 
    % nallc = number of all constituents
    nallc = size(coef.g,1);
    % reshape t to a vector
    if size(tin,2)>1
        tin = reshape(tin,n_t,n_s);
    end
    % reshape fields of coef to vectors
    if n_d > 1
        coef.g = reshape(coef.g,nallc,n_s);
        coef.g_ci = reshape(coef.g_ci,nallc,n_s);
        if coef.aux.opt.twodim 
            coef.Lsmaj = reshape(coef.Lsmaj,nallc,n_s);
            coef.Lsmaj_ci = reshape(coef.Lsmaj_ci,nallc,n_s);
            coef.Lsmin = reshape(coef.Lsmin,nallc,n_s);
            coef.Lsmin_ci = reshape(coef.Lsmin_ci,nallc,n_s);
            coef.theta = reshape(coef.theta,nallc,n_s);
            coef.theta_ci = reshape(coef.theta_ci,nallc,n_s);
            coef.umean = reshape(coef.umean,1,n_s);
            coef.vmean = reshape(coef.vmean,1,n_s);
            if ~coef.aux.opt.notrend
                coef.uslope = reshape(coef.uslope,1,n_s);
                coef.vslope = reshape(coef.vslope,1,n_s);
            end
        else
            coef.A    = reshape(coef.A,nallc,n_s);
            coef.A_ci = reshape(coef.A_ci,nallc,n_s);
            coef.mean = reshape(coef.mean,1,n_s);
            if ~coef.aux.opt.notrend
                coef.slope = reshape(coef.slope,1,n_s);
            end
        end
        coef.aux.reftime = reshape(coef.aux.reftime,1,n_s);
        if size(coef.aux.lat,2)>1
            coef.aux.lat = reshape(coef.aux.lat,1,n_s);
        end
    end
    % initialize storage
    u = nan*ones(n_t,n_s);
    if coef.aux.opt.twodim
        v = u;
    else
        v = [];
    end
    % main loop
    coef1.aux.frq = coef.aux.frq;
    coef1.aux.lind = coef.aux.lind;
    coef1.aux.opt = coef.aux.opt;
    for is = 1:n_s % for each time sequence
        
% % %         if size(tin,2) > 1
% % %             tin1 = tin(:,is);
% % %         else
% % %             tin1 = tin;
% % %         end
        
           uin1 = uin(:,is);
        if ~isempty(vin)
            vin1 = vin(:,is);
        else
            vin1 = [];            
        end
        
        if isequal(size(uin),size(tin))
            tin1 = tin(:,is);
        else
            tin1 = tin;
        end
        
        
        % select coef results for the is'th record
        coef1.name = coef.name;
        coef1.g    = coef.g(:,is);
        coef1.g_ci = coef.g_ci(:,is);
        if coef.aux.opt.twodim
            coef1.Lsmaj = coef.Lsmaj(:,is);
            coef1.Lsmaj_ci = coef.Lsmaj_ci(:,is);
            coef1.Lsmin = coef.Lsmin(:,is);
            coef1.Lsmin_ci = coef.Lsmin_ci(:,is);
            coef1.theta = coef.theta(:,is);
            coef1.theta_ci = coef.theta_ci(:,is);
            coef1.umean = coef.umean(is);
            coef1.vmean = coef.vmean(is);
            if ~coef.aux.opt.notrend
                coef1.uslope = coef.uslope(is);
                coef1.vslope = coef.vslope(is);
            end
        else
            coef1.A = coef.A(:,is);
            coef1.A_ci = coef.A_ci(:,is);
            coef1.mean = coef.mean(is);
            if ~coef.aux.opt.notrend
                coef1.slope = coef.slope(is);
            end
        end
        if size(coef.aux.lat,2)>1
            coef1.aux.lat = coef.aux.lat(is);
        else
            coef1.aux.lat = coef.aux.lat;
        end
        coef1.aux.reftime = coef.aux.reftime(is);
        
        % execute reconstruct for one record
        % fprintf('[%d/%d]',is,n_s);
        
        coef_boot = cut_boot1(tin1,uin1,vin1,coef1,n_boot,varargin{:});
        
       
        
        % store results
% % %         u(:,is) = u1;
% % %         if coef.aux.opt.twodim
% % %             v(:,is) = v1;
% % %         end
    end
    
    % reshape back to original array sizes
%     if n_d > 1
%         u = reshape(u,[n_t alln]);
%         if coef.aux.opt.twodim
%             v = reshape(v,[n_t alln]);
%         end
%     end
%}
end

